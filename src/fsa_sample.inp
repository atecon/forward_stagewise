set verbose off
clear

#include ridge.gfn --force

set workdir "/home/at/git/forward_stagewise"

include string_utils.gfn
#include ridge.gfn           # min. v1.11
include "./src/fsa.inp" --force

scalar runEX = 3		# select an example

# specify some penalty values
# TODO: let's do the following within the function:
/* If the user doesn't specify lambda or nlambda,
 we set nlambda=100 and lmax=400
 In glmnet() a pre-check is ran: set lmax
 there where most coefficients are 'close to zero'
*/

# Select an example
if runEX==1
    open australia.gdt -q --preserve

    # define the variables
    series LHS = ldiff(PAU)
    list RHS = const LHS(-1 to -2) IUS(-1 to -2)  IAU(-1 to -2)

    ols LHS RHS

elif runEX==2
    # Dataset from glmnet
    open "@wd/glmnet_QSE.csv" --quiet  --preserve
    setobs 1 1 --special-time-series
    setobs 1 1 --cross-section

    rename X1 LHS
    list RHS = const dataset
    RHS -= LHS

elif runEX==3
    # SIMULATION
    nulldata 500
    #set seed 1234
    setobs 1 1 --time-series
    scalar k = 35
    series e = normal()
    series LHS = 1
    series LHS = 4.5 + 0.8*LHS(-1) - 0.4*LHS(-2) + e
    matrix X = mnormal($nobs, k)		# further exogenous
    list RHS = const LHS(-1 to -6)		# arbtrary lags of the endogenous
    loop i=1..cols(X) -q
        RHS += genseries(sprintf("S%d", $i), X[,i])
    endloop

    ols LHS RHS
endif

# run the main function with default values
bundle opts = null

# Run estimation
bundle B = fsa(LHS, RHS, opts)
print B

print_estimation_results(B)

# Retrieve point estimates
eval B.coeff            # retrieve point estimates of all variables
eval B.coeff_nonzero    # retrieve point estimates of selected variables

# Plot correlations as a function of iterations
plot_rho_values(B)

# Plot coefficient paths
#plot_coefficient_paths(B)

