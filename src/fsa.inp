function bundle default_fsa_opts (const series y,
                                const list X)

    # Set default values
    bundle self = null
    scalar self.verbose = 1
    scalar self.eta = 0.001         # kind of learning rate
    scalar self.n_iterations = 500
    scalar self.threshold_correlation = 0.05    # min. (absolute) correlation needed before early stopping

    return self
end function


function void stdize_y_and_x (bundle *self)
    /* Demeaning series y and list X and compute associated std.-errors. */
    matrix my = cdemean({self.y})
    scalar self.ysd = sdc(my)
    self.my = my ./ self.ysd
    matrix mX = cdemean({self.X_without_const})
    matrix self.Xsd = sdc(mX)           # gives row vector
    self.mX = mX ./ self.Xsd
end function


function bundle fsa (series y "Dep. variable",
                       list X "Candidates",
                       bundle opts[null])

    /* Main function */

    smpl y X --no-missing         # TODO: impacts on initial_residuals

    bundle self = default_fsa_opts(y, X)
    if exists(opts)
        self = opts + self         # override defaults
    endif


    # Initilizations
    series self.y = y
    list self.X = X
    string self.ynames = argname(y)
    strings self.Xnames = varnames(X)
    list self.X_without_const = X - const
    scalar self.with_constant = nelem(self.X_without_const) < nelem(self.X) ? TRUE : FALSE
    strings self.Xnames = (self.with_constant == TRUE) ? strdrop(self.Xnames, "const") : self.Xnames


    stdize_y_and_x(&self)

    # Initializations of variables for estimator function
    matrix self.rho_values = mshape(NA, self.n_iterations, 1)
    matrix self.betas = zeros(self.n_iterations, cols(self.mX))
    scalar self.last_iteration = NA

    fsa_estimator(&self)

    # postprocessing
    cnameset(self.betas, self.Xnames)
    self.betas = cum(self.betas)
    self.betas = self.betas[1:self.last_iteration, ]
    self.rho_values = self.rho_values[1:self.last_iteration]

    return self
end function


function scalar forward_stagewise (const bundle self,
                                    const scalar rho "Correlation coefficient")
    /* Compute forward stagewise "delta" value. */
    return self.eta * sgn(rho)
end function


function scalar update_beta (const scalar beta, const scalar delta)
    /* Update regression coefficient. */

    return beta + delta
end function


function matrix update_residuals (const matrix residuals,
                                const scalar delta,
                                const matrix x "j-th regressor")
    /* Update regression coefficient. */

    return residuals - delta * x
end function


function scalar get_max_correlation (const matrix yX, scalar *position "j-th regressor")
    /* Compute correlations between "y" and all exogenous variables ("X"). Return maximum of absolute correlations. */

    matrix correlations = mcorr(yX)[2:, 1]      # assume that 1st column refers to endogenous
    scalar position = imaxc(abs(correlations))

    return correlations[position]
end function

function void print_early_stopping_reached (const bundle self,
                                            const scalar rho,
                                            const int iteration)
    /* */

    if self.verbose > 0
        printf "\nInfo: Correlation abs(%g) is lower than minimum required (%g) at iteration % out of %d.\n", abs(rho), self.threshold_correlation, iteration, self.n_iterations
    endif
end function



function void print_iteration_details (const bundle self,
                                        const int iteration)
    /* */

    if self.verbose == 2
        printf "\nInfo: Iteration %d out of %d.\n", iteration, self.n_iterations
    endif
end function


function void fsa_estimator (bundle *self)
    /* Actual implementation of the boosting-like forward stagewise algorithm. */

    matrix yX = self.my ~ self.mX

    loop i = 1..self.n_iterations
        scalar position = NA
        scalar self.last_iteration = $i
        scalar col = (i > 1) ? i-1 : 1

        print_iteration_details(self, $i)

        self.rho_values[i] = get_max_correlation(yX, &position)
        scalar delta = forward_stagewise(self, self.rho_values[i])

        self.betas[i, position] = update_beta(self.betas[i, position], delta)
        yX[,1] = update_residuals(yX[,1], delta, self.mX[, position])

        if abs(self.rho_values) < self.threshold_correlation
            print_early_stopping_reached(self, abs(self.rho_values[i]), $i)
            break
        endif
    endloop
end function


function void plot_coefficient_paths (bundle self, const bool ylog_scale[0])
    /* Plot coefficient paths. */

    string self.coeffplot_title = "Forward stagewise coefficient paths"
    string self.ylabel = (ylog_scale == FALSE) ? "Standardized coefficients" : "Standardized coefficients (in logarithms)"
    scalar self.coeffplot_fontsize = 12
    string self.coeffplot_filename = "display"
    string coeffplot_filename = self.coeffplot_filename
    string ylog_scale_str = (ylog_scale == TRUE) ? "--ylogscale=10" : ""
    matrix mplot = self.betas
    cnameset(mplot, self.Xnames)


    plot mplot
        options with-lp time-series single-yaxis @ylog_scale_str
       #literal set linetype 3 lc rgb "#0000ff"
       #literal set nokey
       literal set grid
       printf "set title \"%s\" font \", %d\"", self.coeffplot_title, self.coeffplot_fontsize
       printf "set xlabel 'Iteration' font \", %d\"", self.coeffplot_fontsize
       printf "set ylabel '%s' font \", %d\"", self.ylabel, self.coeffplot_fontsize
   end plot --output="@coeffplot_filename"
end function


function void plot_rho_values (bundle self, const bool absolute_values[0])
    /* Plot correlation coefficients. */

    string self.rhoplot_title = "Forward stagewise correlation values"
    string self.ylabel = ""
    scalar self.rhoplot_fontsize = 12
    string self.rhoplot_filename = "display"
    string filename = self.rhoplot_filename

    matrix mplot = (absolute_values == TRUE) ? abs(self.rho_values) : self.rho_values

    plot mplot
       options with-lines time-series
       literal set nokey
       literal set grid
       printf "set title \"%s\" font \", %d\"", self.rhoplot_title, self.rhoplot_fontsize
       printf "set xlabel 'Iteration' font \", %d\"", self.rhoplot_fontsize
       #printf "set ylabel '%s' font \", %d\"", self.ylabel, self.rhoplot_fontsize
   end plot --output="@filename"
end function


/*
# TODO:
add UDFS for plotting
#gnuplot 1 --with-lines --time-series --matrix=rho_values --output="display"

*/


